#algorithms #bigo 

### Ресурсы
1. Видео: https://youtu.be/ZRdOb4yR0kk
2. Статья: https://tproger.ru/articles/computational-complexity-explained/

### Про сложность алгоритмов

**Сложность алгоритма** - порядок количества действий, которые выполняет алгоритм.

**Big O**:
* математическое обозначение для сравнения асимптотических функций;
* показывает вернюю границу зависимости между входными параметрами функции и   количеством операций, которые выполнит процессор.

*Ex*
- O(n) - линейная
- О(log n) - логарфимическая
- O($n^{2}$) - квадратичная

Также есть *пространственная сложность* - количество дополнительной (?) памяти. Суть, требуется понять, сколько максимально памяти сожрет алгоритм.

*Note Про О* О-нотация - это ограничение асимптотической сложности сверху, с точностью до константного множителя (алгоритм совершит не больше, чем *столько-то* действий).

При оценке времязатратности алгоритмов отбрасываются константы. Например, если совершается N действий + k действий на вывод информации и/или подготовительный этап, то сложность алгоритма будет равна O(N), т.к. считается, что N >> k. Аналогично 
`O(2 * N) == O(N)`, если в цикле выполняется 2 действия, а не одно и т.д. 

Сложность O($n^{2} + n$) это все еще O($n^{2}$), т.к. степенная функция растет быстрее линейной, значит более медленно растущую часть можно отбросить. Применяется терминология "значительно больше" или же "как минимум, в два раза".

Сложность O($n^{2} + B$) это все еще O($n^{2} + B$), т.к. мы ничего не знаем о B.

### Примеры расчета Big O.

**Ex 1**
```
def sum(n):
    if n == 1:
        return 1
    return n + task_test(n - 1)

sum(n)
```
При `n = 3` будет выполнено 3 операции, при `n = 6` - 6 операций и т.д. Сложность данного алгоритма линейная, O(N).

**Ex 2**
```
def foo(n, m):
    for i in range(n):
        print(i)
    for i in range(m):
        print(m)
```
Сложность такого алгоритма будет равна O(N + M), т.к. циклы выполняются последовательно и независимо друг от друга.

**Ex 3**
```
def foo(n, m):
    for i in range(n):
        for j in range(m):
            print(n, m)
```
Сложность такого алгоритма будет равна O(N * M), т.к. будет выведено m выражений n раз.

**Ex 4**
```
def foo(n, m):
    for i in range(n):
        for j in range(i, m):
            print(n, m)
```
Сложность такого алгоритма $O(N + N - 1 + ... + 2 + 1)$ = $O(N^{2}/2)\approx O(N^{2})$ .