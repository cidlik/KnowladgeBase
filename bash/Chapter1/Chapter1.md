#bash #base

# Ресурсы

1. Статья: https://habr.com/ru/companies/ruvds/articles/325522/
2. ABS Guide: https://tldp.org/LDP/abs/html

# Заметки

* Шебанг - последовательность символов ``#!``. Устанавливается на первой строке
  скрипта с дальнейшим указанием **полного** пути до интерпретатора. Подробное
  описание по [ссылке](https://linux.die.net/man/2/execve).

    * Также сразу отмечу разницу между ``#!/usr/bin/python`` и
    ``#!/usr/bin/env python``. В целом, можно использовать обе две конструкции,
    но вторая более гибкая. ``.../env python`` позволяет получить из PATH первый
    испольняемый файл python (а их может быть несколько). Использование же
    ``#!/usr/bin/python`` означает, что скрипт будет использовать только этот
    файл в качестве интерпретатора (обычно это симлинк).

* Для исполнения скрипта без указания интерпретатора следует сделать его
  исполняемым командой ``chmod +x ...``. Для просмотра разрешений файла можно
  использовать ``ls -l`` или ``stat``. Подробнее см.
  [тут](https://askubuntu.com/a/528433).

## Переменные

В статье выделяют:

* Переменные окружения (environment variables);
* Пользовательские переменные (shell variables).

Для создания переменных окружения используется ``export <VAR>=<VALUE>``.
Пользовательскую перменную можно создать обычным присваиванием ``<VAR>=<VALUE>``.
Как сказано в [комментарии](https://askubuntu.com/a/26322), переменные окружения
глобальные и доступные как в самой оболочке, так и в запускаемых программах.
Переменные окружения можно просмотреть, вызвав ``env`` или ``printenv``.

Для демонстрации разницы используется скрипт ``var.sh``. Переменная окружения
``FOO`` видна в генерируемом скрипте tmp.sh, а ``XYZ`` - нет.

## Подстановка команд

Выполняется:

* при помощи бэктика:
  ```
  echo `pwd`
  ```
* при помощи конструкции ``$()``: ``echo $(pwd)``

TODO: Где-то тут, наверное, должно быть про различие между одинарными кавычками
и двойными.

## Математические операции

Математические операции могут быть выполнены при помощи конструкции ``$((...))``.
Примеры в ``math.sh``

## Ветвления

В наиболее простом виде выглядит как:

```
if условие
then
  команды А
elif условие
  команды B
else
  команды C
fi
```

Отмечу, что верное условие == команда возвращает 0, если ее ввести в терминале.
Пример:

```
# set -e; if false; then echo false; else echo true; fi; set +e
true
# false; echo $?
1
# true; echo $?
0
```

Т.об., можно не переживать, что команда в условии сломает скрипт.

## Сравнения

См. https://tldp.org/LDP/abs/html/comparison-ops.html#EX13

### Про одиночные и двочные квадратные скобки

```
[rkuznecov@dojo-pc chapter1]$ type -a [
[ is a shell builtin
[ is /usr/bin/[
[rkuznecov@dojo-pc chapter1]$ type -a [[
[[ is a shell keyword
```

Прошу прощения, но... `[` - ЭТО БЛЯТЬ ИСПОЛНЯЕМЫЙ ФАЙЛ???? ШОК!

``test expr == [ expr ]``.

Источник: https://unix.stackexchange.com/a/99186

Согласно [комментарию](https://stackoverflow.com/a/47576482), предпочтительнее
использовать одиночные скобки, т.к. они определены в POSIX. Двойные же являются
расширением Bash, т.е., могут не поддерживаться в других оболчках. Короче, у
одиночных скобок переносимость лучше.


### Сравнения чисел

Файл: ``num-comp.sh``

Для сравнения чисел могут быть использованы ключи

| Выражение | Расшифровка       | Комментарий                                               |
| --------- | ----------------- | --------------------------------------------------------- |
| n1 -eq n2 | equal             | Возвращает истинное значение, если n1 равно n2.           |
| n1 -ge n2 | greater or equal  | Возвращает истинное значение, если n1больше или равно n2. |
| n1 -gt n2 | greater then      | Возвращает истинное значение, если n1 больше n2.          |
| n1 -le n2 | lesser or equal   | Возвращает истинное значение, если n1меньше или равно n2. |
| n1 -lt n2 | lesset then       | Возвращает истинное значение, если n1 меньше n2.          |
| n1 -ne n2 | not equal         | Возвращает истинное значение, если n1не равно n2.         |

Пара замечаний:

* Можно использовать сравнение без ветвления;
* Критичным является использование пробела между квадратной скобкой и частью
  выражения:

  ```
  [rkuznecov@dojo-pc chapter1]$ [ 5 -eq 3 ]
  [rkuznecov@dojo-pc chapter1]$ [5 -eq 3]
  bash: [5: command not found...
  [rkuznecov@dojo-pc chapter1]$ [ 5 -eq 3]
  bash: [: missing `]'
  [rkuznecov@dojo-pc chapter1]$ [5 -eq 3 ]
  bash: [5: command not found...
  ```

  *UPD* После прочтения раздела "Про одиночные и двочные квадратные скобки"
  становится понятно, почему. Потому что `[` - shell builtin, как бы отдельная
  утилита.

* При использовании двойных квадратных скобок нет возможности указать операторы
  "больше или равно" или "меньше или равно".


## Сравнение строк

Файл: ``str-comp.sh``

| Выражение     | Комментарий                                                               |
| ------------- | ------------------------------------------------------------------------- |
| str1 = str2   | Проверяет строки на равенство, возвращает истину, если строки идентичны.  |
| str1 != str2  | Возвращает истину, если строки не идентичны.                              |
| str1 < str2   | Возвращает истину, если str1 меньше, чем str2 (первый символ в ASCII)     |
| str1 > str2   | Возвращает истину, если str1 больше, чем str2 (первый символ в ASCII)     |
| -n str1       | Возвращает истину, если длина str1больше нуля.                            |
| -z str1       | Возвращает истину, если длина str1равна нулю.                             |


## Проверки файлов

См. https://tldp.org/LDP/abs/html/refcards.html#AEN22593

Файл: ``files.sh``

| Выражение         | Расшифровка   | Комментарий                               |
| ----------------- | ------------- | ----------------------------------------- |
| -d file           | directory     | Проверяет, существует ли файл, и является ли он директорией. |
| -e file           | exists        | Проверяет, существует ли файл. |
| -f file           | regular file  | Проверяет, существует ли файл, и является ли он файлом. |
| -r file           | readable      | Проверяет, существует ли файл, и доступен ли он для чтения. |
| -s file           | size          | Проверяет, существует ли файл, и не является ли он пустым. |
| -w file           | writable      | Проверяет, существует ли файл, и доступен ли он для записи. |
| -x file           | executable    | Проверяет, существует ли файл, и является ли он исполняемым. |
| file1 -nt file2   | newer than    | Проверяет, новее ли file1, чем file2. |
| file1 -ot file2   | older thane   | Проверяет, старше ли file1, чем file2. |
| -O file           | own the file  | Проверяет, существует ли файл, и является ли его владельцем текущий пользователь. |
| -G file           | group id      | Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.   |

Замечания:

* Судя по всему, проверка на старость и новость файлов выполняется как по
  дате создания, так и по дате изменения.
