# Заметки

### Книги

* Understanding the Linux kernel. Daniel P.Bovet
* Linux System Programming

### Вводные про написание кода для ядра и модулей

Лектор говорит, что "как только программист начинает пользоваться системными
вызовами, команды, возможности (e.g. float point ops), то он начинает писать
в user-space. При программировании ядра это недопустимо".

Некоторые пояснения к этому мнению:

* При написании kernel-space кода не рекомендуется использовать float point
  вычисления, потому что не во всех ядрах (полагаю, речь именно о ядрах железа)
  поддержаны операции с плавающей точкой. Например, пользовательское приложение
  может использовать все типы данных, но при обращении к kernel-space эти
  операции могут "оборачиваться" софтварное вычисление.
* На уровне ядра используются fixed point operations (с фиксированной точкой).
* Ядро не умеет округлять.
* `printf()` не используется ядром, т.к. эта команда выполняет системный вызов
  `write()`. `printk()` - вывод на уровне ядра. Запись производится в системный
  журнал. Видимо, потом выполняется чтение журнала в `stdout`.
* Ну и конечно же не стоит полагаться на привычные библиотеки (`stdio, stdlib`).
* При написании программ с потоками ввода-вывода обычно считается, что `out`
  выводит информацию приложения, а `in` позволяет получить программе данные.
  С ядром все наоборот, для ядра `in` - запись информации, чтобы программа в
  `in` ее получила, а `out` - чтение.

### База про ядро

**Ядро** - программа, которая реализует:

* интерфейс системных вызовов - самая верхняя информация о ядре, интерфейс,
  позволяющий управлять ядром:

    * управление процессором;
    * управление памятью;
    * управление файловой системой (разными);
    * управление устройствами;
    * управление сетью.

*Note* Разделяют **макро**- и **микро**-ядра. У Linux'a макро-ядро монолитное.
Все компоненты сразу загружаются в ОЗУ.

Лектор говорит, что отдают предпочтение макроядрам, т.к. там реализовано много
сложной "математики". Если требуется обеспечить высокую отказоустойчивость, то
используют макроядро модульное, чтобы в случае проблемы перезагрузить модуль.

/*Зачем это?*/
Некоторые особенности программирования:

* Платформо-зависимый код;
* Динамическое управление памятью;
* Определение типов файловой системой.

### Что-то про kernel space

* kernel space не должно занимать всю доступную память (но вот почему, пока не
  понятно).
* Код в пространстве должен быть реентерабельным (reenterant) - безопасным.
  Цитата из Вики:

  ```
  Компьютерная программа в целом или её отдельная процедура называется
  реентера́бельной (от англ. reentrant — повторно входимый), если она разработана
  таким образом, что одна и та же копия инструкций программы в памяти может быть
  совместно использована несколькими пользователями или процессами.
  ```

  Пример нереентерабельного кода

  ```
  #include <stdio.h>

  int f()
  {
      static int i = 1;
      return i = i + 1;
  }

  int main()
  {
      printf("%d\n", f());
      printf("%d\n", f());

      return 0;
  }
  ```

* При создании модуля ядра требуется указывать макросы с указанием автора и
  лицензии.
