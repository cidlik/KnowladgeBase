#algorithms #sort

В данной главе рассказ начинается со сравнения массивов и связанных списков. 
Говорится, что **массив** - структура данных, позволяющая разместить данные в памяти непрерывно.
(+) Данные рядом, не надо искать
(-) Могут начаться проблемы, если придется расширять массив, т.к. соседние ячейки памяти могут быть заняты. В таком случае для размещения массива придется искать новое место.
Связанный список - структура, хранящая как значение, так и ссылку на следующий элемент.
(+) Данные могут быть разбросаны по памяти как угодно
(-) Нет прямого доступа к элементам, так как каждый элемент знает только о своем следующем соседе. Если нужно получить, скажем, последний элемент связанного списка, то нужно пройтись по всему списку.

**Вывод**: связанные списки отлично подходят для тех случаев, когда нужно получать данные последовательно. Если требуется быстро получать любые элементы, то лучше использовать массивы.

|         | Массив | Список |
|---------|--------|--------|
| Чтение  | O(1)   | O(n)   |
| Вставка | O(n)   | O(1)   |

*Note* Данная таблица справедлива для списков в том случае, если можно моментально получить доступ к элементу.

Автор книги говорит, что в случае с вставкой в середину также проще использовать связаные списки, т.к. для этого потребуется изменить ссылку в предыдущем элементе. В случае с массивами все также придется сдвигать элементы и искать новый участок памяти, если текущего недостаточно.
Почти то же самое справедливо и для удаления, кроме поиска нового участка памяти, т.к. кол-во памяти, занимаемой структурой только уменьшится.

### Сортировка выбором

Пример реализации:
```
def selection_sort(a: list or array, inc_order: bool = True) -> list or array:
	# проверка типа получаемого объекта
    if isinstance(a, list):
        ret = list()
    elif isinstance(a, array):
        ret = array("i", [])
    else:
        print(f"type {type(a)} is unsupported")
        return -1

	# выбор порядка сортировки: по возрастанию или убыванию
    if inc_order:
        exp = lambda x, y: x < y
    else:
        exp = lambda x, y: x > y

    while len(a):
        tmp = a[0]
        pos = 0
        for i, el in enumerate(a):
            if exp(el, tmp):
                tmp = el
                pos = i
        ret.append(tmp)
        a.pop(pos)
```

Сложность по времени: $O(n^{2}$)
Затраты по памяти: 
* $O(n)$ - основной - создается новый массив, длина которого соответствует длине исходного;
* $O(1)$ - заводятся всякие переменные, дополнительные затраты константные.