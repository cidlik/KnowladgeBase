#algorithms #binary_search

### Про бинарный поиск

**На вход** алгоритма бинарного поиска подается отсортированный список элементов.
**На выходе** алгоритма:
* если элемент был найден, то его позиция;
* если не найден, то `None/null/-1` etc.

*Note* Сама идея, в сравнении, с простым ("тупым") поиском прикольная. Если простой поиск за одну итерацию проверяет исключает только одно число, то бинарный поиск - половину от всех элементов.

Сложность данного алгоритма - `O(log(N))`. Если:
* `N = 64`, то максимальное количество операций для поиска = 6;
* `N = 100`, то максимальное количество операций для поиска = 7 (`floor(log(100)) + 1`).

Возможная реализация:
```
def binarySearch(a: array or list, t: int) -> int:
    left = 0
    right = len(a) - 1
    while left <= right:
        mid = (right + left) // 2
        if a[mid] == t:
            return mid
        if a[mid] < t:
            left = mid + 1
        elif a[mid] > t:
            right = mid - 1
    return None
```

Комментарии:
* 1 в `left = mid + 1` и `ight = mid - 1` позволяет в слеующих итерациях поиска не использовать элемент `mid`, т.к. мы его только что проверили.
* Знак `<=` в `left <= right` позволяет избежать ошибки в случае, когда искомое число самое правое.
  *Ex*
  `a = [ 0, 2, 4, 6, 8, 10, 12, 14, 16], target = 16`
```
left <= right

array: array('i', [0, 2, 4, 6, 8, 10, 12, 14, 16])
search: 16
mid: 4; t: 16; left: 0; right: 8
mid: 6; t: 16; left: 5; right: 8
mid: 7; t: 16; left: 7; right: 8
mid: 8; t: 16; left: 8; right: 8
element 16 in 8 position

================
left < right

array: array('i', [0, 2, 4, 6, 8, 10, 12, 14, 16])
search: 16
mid: 4; t: 16; left: 0; right: 8
mid: 6; t: 16; left: 5; right: 8
mid: 7; t: 16; left: 7; right: 8
element 16 was not found
```


### Про задачу про коммивояжера

TBU
