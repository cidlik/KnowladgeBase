#algorithms #bfs #collections 

**BFS** - Breadth-First Search - поиск в ширину.

### Про графы

<img src=".\img\ch6_1.png" alt="ch6_1">

Узел может быть соединени с другими узлами - *соседями*.
Графы могут быть *ориентированными* и *неориентированными*.

Поиск в ширину работает с графами. Как пишет автор, данный алгоритм позволяет понять:
* существует ли путь от одного узла до другого;
* кратчайший путь от одного узла к другому.

### Про поиск

##### Проверка, существует ли путь.
Алгоритм проверки существования пути сводится к следующему. Сначала проверяется, есть ли узлы-соседи по очереди. Добавляем их в список поиска. Если это не искомый узел, то проверяем следующего соседа и т.д. Когда всех соседей проверили, нужно проверить соседей соседей, добавляем их в список поиска и т.д., пока или все не обойдем и не уйдем ни с чем, или не наткнемся на искомый узел.
Для проведения такой операции используется структура данных *очередь* - FIFO.

*чуть по-другому*. Ищем соседей для первого узла, добавляем их в FIFO. Проверили первого соседа, если не искомый, то добавили его соседей в FIFO, далее второй сосед первого уровня и так, пока не кончатся соседи первого уровня. Потом проходим по соседям второго уровня, добавляем соседей третьего уровня и т.д.

*и еще по-другому*

<img src="img\ch6_2.png" alt="ch6_2">

Реализацию см. в `Chapter6.py`.

Автор говорит, что следует проверять, проверяли ли уже этот элемент. Иначе:
* будет выполняться дополнительная работа;
* может возникнуть бесконечный цикл. 

*Note* Текущая реализация позволяет определить существование кратчайшего пути, но не показывает длину этого пути и сам путь.

**Время выполнения** - $O(V+E)$, где
* $V$ - количество вершин;
* $E$ - количество ребер.

*Заметка по решению*
* `first_var()` - решение по книжке, не показывает короткий путь и его длину;
* `second_var()` - решение по [видео](https://www.youtube.com/watch?v=xXvNDrF4obQ) , показывает и путь, и его длину.

